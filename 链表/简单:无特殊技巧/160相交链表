# 编写一个程序，找到两个单链表相交的起始节点。
# 如下面的两个链表：
# 在节点 c1 开始相交。
# 示例 1：
# 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
# 输出：Reference of the node with value = 8
# 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
# def getIntersectionNode(self, headA, headB):
# headA, headB: ListNode
# return: ListNode


# 思路：题号往前翻一点遇到过与这题很相似的环形链表问题, 所以很直观的就可以想到使用字典
# 或者直接对链表的值进行改写以达到标记'已遍历过'的标志,同时这道题要求给出具体的序号
# 那么把节点值修改为先行开动的链表的序号的字符串形式, 以区别为遍历的整型形式会是一个不错的选择
# 由于题目最后需要返回的是一个未经修改的节点, 所以改用字典来记录
# 当然这道题还有一个很巧妙的双指针解法, 运用的是数学方法, 两个节点分别从两条链表的头部开始
# 遍历, 当遍历完链表之后, 直接从另一条链表的头部继续开始遍历, 由于这样的遍历方式会使
# 两个节点都遍历了2条链表的区别部分各一次和两条链表的公共部分一次, 所以两个节点将会
# 在两条链表的公共部分的开端相遇, 此时提交这个节点就可以了(这个方法有一个很大的问题,
# 当一条链表是另一条链表的子链表时, 将不可能相遇(需要处理这个问题)
# 由于题目并没有太多的限制要求, 所以我选择写法和思路都很简单的字典的方法来解答
# 果然数据结构就是强大, 简单粗暴击败99.95, 写起来还特别简洁, 要什么自行车?


class Solution(object):
    def getIntersectionNode(self, headA, headB):
        dct = {}
        while headA != None:
            dct[headA] = 0
            headA = headA.next
        while headB != None:
            if headB in dct:
                return headB
            headB = headB.next
        return None
