# 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点
# 分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
# 说明：你不能倾斜容器，且 n 的值至少为 2。
# 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
# 示例:
# 输入: [1,8,6,2,5,4,8,3,7]
# 输出: 49
# def maxArea(self, height: List[int]) -> int:


# 思路：这道题其实规律是很简单的, 但是想要看出规律或者证明规律却很难, 我简单指出这个规律
# 在这么多高低不同的木板构成的区域中, 能够盛最多水的区域是哪一个不好判断, 但是我们可以
# 通过缩小宽度来寻找下一种储水量更大的可能性, 找出其中储水量最大的可能性就是结果
# 这个规律是什么? 我们可以假设宽度完整的时候, 能盛的水是最多的, 然后找寻下一个盛更多水的可能性
# 这个可能性要怎么去找呢? 减少宽度, 看看能不能增加存水的高度
# 其实就是让两个指针从两边往中间走, 他的宽度是一直在降低的,
# 同时给一个判断, 如果左右指针的高度不同, 则高的指针停下, 矮的指针移动
# 这意味着我们一直在往更大的储水量的可能性发展
# 一直往中间靠拢, 直至宽度为1, 这里面一定包含了盛水量最大的可能性, 然后比较各种宽度下最大的
# 盛水量, 求出所有宽度下最大盛水量


class Solution:
    def maxArea(self, height):
        l = 0
        r = len(height) - 1
        res = 0
        while l < r:
            if height[l] < height[r]:
                res = max(min(height[l], height[r]) * (r - l), res)
                l += 1
            else:
                res = max(min(height[l], height[r]) * (r - l), res)
                r -= 1
        return res
