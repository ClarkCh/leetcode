# 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
# 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
# 必须原地修改，只允许使用额外常数空间。
# 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
# 3,2,1 → 1,2,3
# 1,1,5 → 1,5,1
# def nextPermutation(self, nums: List[int]) -> None:


# 思路：首先这道题题目解释完全不能理解, 在看了其他人的解释之后我给出了一个更容易看懂的解释
# 这道题不使用回溯, 但是跟回溯、全排列关系十分密切, 因为回溯其实是一种思想, 一种关于有顺序的
# 获取符合题意的所有可能并在过程中(在index == n 之前)筛选出合理可能(剪枝)的思想,
# 有序地获取所有可能恰恰就是全排列的思路
# 以123456为例, 把这6个数不重复的使用组合出的可能共有A6(6)即6!种,按照全排列的正常顺序输出
# 应该是123456, 123465, 123456, 123564 …… 到最后一种654321, 题目输入一种可能性, 我们的结果
# 就输出下一种可能性, 如果题目输入最后一种可能性, 那么我们就输出第一种可能性
# 那么基本的回应机制就是, 1)如果参数是最后一种可能性, 我们就返回第一种
# 2)如果倒数第一个数比倒数第二个数大, 则只调换这两个数
# 3)如果后面有一段倒序的数, 那按照全排列的思路去分析, 应该轮到这段倒序的数的前一个数变大了(其实第2种是第3种的子集)


class Solution:
    def nextPermutation(self, nums):
        size = len(nums)
        # 小于2个数不用管
        if size < 2:
            return
        # 上面提到的第二种可能
        if nums[-1] > nums[-2]:
            nums[-1], nums[-2] = nums[-2], nums[-1]
            return
        maxinum = 0
        rec = nums[-1]
        for i in range(1, size + 1):
            if maxinum < nums[-i]:
                maxinum = nums[-1]
            if nums[-i] < rec:
                break
            else:
                rec = nums[-i]
        # 上面提到的第一种可能
        if i == size and nums[0] >= nums[1]:
            nums.reverse()
            return
        # 上面提到的第三种可能, 需要以下操作
        # 刚才-i(因为我是从右往左数的)就是123765中的3所在的位, 现在我要寻找一个比3而且最接近3的位
        if nums[-1] > nums[-i]: # 如果倒数第一位就比-i位的数大, 直接交换, 因为倒数第2,3,4位只会更大
            nums[-1], nums[-i] = nums[-i], nums[-1]
        else:
            # 如果倒数第一位没有-i位大, 那就需要好好分析了, 先假设是-i+1位的数(因为他是[-i:-1]这段中最大的数)
            # 如果找到一个比他更贴近-i位的值的位, 更新为k, 并交换
            # 结果就会从 126 865 变成    128  665(-3位和-4位交换) 最后将后半段翻转一下
            total = nums[-i + 1] - nums[-i]
            k = i - 1
            for j in range(1, i):
                total = nums[-j] - nums[-i]
                if 0 < total < rec:
                    k = j
                    rec = total
            nums[-i], nums[-k] = nums[-k], nums[-i]
        mid = int(i / 2 - 0.5)
        for j in range(1, mid + 1):
            nums[-j], nums[-(i - j)] = nums[-(i - j)], nums[-j]
