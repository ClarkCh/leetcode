# 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
# 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
# 示例 1:
# 给定数组 nums = [1,1,2],
# 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
# 你不需要考虑数组中超出新长度后面的元素。
# 示例 2:
# 给定 nums = [0,0,1,1,1,2,2,3,3,4],
# 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
# 你不需要考虑数组中超出新长度后面的元素。
# 说明:
# 为什么返回数值是整数，但输出的答案是数组呢?
# 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
# def removeDuplicates(self, nums: List[int]) -> int:


# 思路:明显的这里要进行原地删除, 所以就是使用偷天换日的手法, 把后一个数的值
# 搬到当前值来, 从而使得该数组的前一部分是没有重复元素的
# 对于处理重复值的方法, 可以使用双指针来找到一个合适放置位置
# 使用慢指针从索引0开始, 如果快指针遇到的值和慢指针的值不同, 说明这个值是应该被归入答案的
# 如果是相同的, 说明这个值应该被闲置, 直接跳过这部分（[i+1, j]这部分是用来放置闲置的值的）
# 等到遇到不同的值, 就把这个值和慢指针的下一个位置交换, 然后把慢指针前移一个
# 这样到慢指针所在的索引部分都是正确的值
# 或者从另一个角度去理解
# 使用r(快指针)在慢指针前一格开始遍历, 如果快指针和慢指针l是相同的值, 说明快指针所在的值应该
# 被换走, 但是还没有找到合适交换的位置, 所以先不管, 快指针继续往前走,指导遇到的值
# 和慢指针的值不同就说明当前快指针所在的值应该就是属于正确答案的一部分, 也是刚才被标记
# 的应该被换掉的值(l+1的格)应该被放置的位置, 把值交换之后, 把慢指针前移一格, 继续重复刚才的操作
# l所在的位置就是没有重复元素的最后一个位置
# 注意：题目要的数值, 是l指针所在索引+1


class Solution:
    def removeDuplicates(self, nums):
        size = len(nums)
        i = 0
        for j in range(1, size):
            if nums[i] != nums[j]:
                nums[i + 1], nums[j] = nums[j], nums[i + 1]
                i += 1
        return i + 1
