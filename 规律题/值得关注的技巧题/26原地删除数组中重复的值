# 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
# 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
# 示例 1:
# 给定数组 nums = [1,1,2],
# 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
# 你不需要考虑数组中超出新长度后面的元素。
# 示例 2:
# 给定 nums = [0,0,1,1,1,2,2,3,3,4],
# 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
# 你不需要考虑数组中超出新长度后面的元素。
# 说明:
# 为什么返回数值是整数，但输出的答案是数组呢?
# 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
# def removeDuplicates(self, nums: List[int]) -> int:


# 思路:明显的这里要进行原地删除, 所以就是使用偷天换日的手法, 把后一个数的值
# 搬到当前值来, 从而使得该数组的前一部分是没有重复元素的
# 对于处理重复值的方法, 可以使用双指针来找到一个合适放置位置
# 使用r(快指针)在慢指针前一格开始遍历, 如果快指针和慢指针l是相同的值, 说明快指针所在的值应该
# 被换走, 但是还没有找到合适交换的位置, 所以先不管, 快指针继续往前走,指导遇到的值
# 和慢指针的值不同就说明当前快指针所在的值应该就是属于正确答案的一部分, 也是刚才被标记
# 的应该被换掉的值(l+1的格), 把值交换之后, 把慢指针前移一格, 继续重复刚才的操作
# l所在的位置就是没有重复元素的最后一个位置
# 注意：题目要的数值, 是l指针所在索引+1


class Solution:
    def removeDuplicates(self, nums):
        size = len(nums)
        if size < 2:
            return size + 1
        l = 0
        r = l + 1
        while r < size:
            if nums[l] != nums[r]:
                nums[l+1], nums[r] = nums[r], nums[l+1]
                l += 1
            r += 1
        return l + 1
