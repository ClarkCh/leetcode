首先明确几点：
回溯法的思想：回溯法是属于暴力破解的一个主要实现手段，基于枚举的特性这种算法思想其实也属于深度优先搜索的一种，并且是偏有序性的枚举手法
（基于题目具体给定的多元素内容的取用顺序来作为一个标准顺序，然后按照顺序枚举出所有可能性直至适当的时候结束）
回溯法的在暴力破解中的地位：作为一个基于一定顺序进行深度遍历的暴力破解手段，其实他的核心思想跟最直接的暴力破解完全是一样的，
区别在于一般情况下如果要进行暴力破解的目标是一个元素特异性低于3的目标，我们可以直接使用3层的for循环进行暴力破解，
但是如果取用元素是不确定的或者是高于3那么使用for循环的写法明显是不简洁甚至实现不了的，这时候就需要写成回溯法的形式，回溯法使用递归，
通过取用元素的进度来判断是否到达了最深的深度，也可以随着给定的元素的量自行决定循环的层数

回溯法的常见使用情景：
1)寻找题目给出的所有(合理)可能性的具体情况
2)基于第一点，我们可以在获得每一种合理可能的具体情况的时候不记录具体情况，而是进行计数，这样可以获取合理可能的数量
3)有能力找出遍历所有可能性，自然也可以在获取了第一种可能性后停止，这也是回溯法的常见使用情景
回溯法与动态规划等算法的关系：客观来说作为暴力破解的主要实现手段，他是可以获取所有可能（包括不合理可能）甚至是所有可能的情况的最具体的表现形式。
而如动态规划一类的算法是放弃了合理可能中的具体表现形式，而只记录下相关的部分内容，举例：如果我们有1~9这9个数要进行9元素组合，
用回溯法可以清楚判断出123456789到987654321中每一种情况的具体表现形式，而动态规划则会通过记表并基于表数据进行延伸，
最终获得答案中的某个方面的答案，比如动态规划可以很容易的判断出组合的可能性，并且操作数对比暴力破解大大减少，
但是如果想要用动态规划来列出所有可能的具体表现形式，这是做不到的，主要是因为记表的操作中无法记录表现形式的，所以基于以上判断，
如果一个题目想要求解的是数量方面的内容，明显使用动态规划是更优的方案，如果需要的是具体表现形式，那么基本就是用回溯法

回溯法中的剪枝：刚才也有提到，回溯法是暴力破解的一种主要实现手段，他不放过任何一种可能的思想让我们能够获得所有应该有可能获得的答案，
但是有时候并不是所有的答案都是题目想要的，比如组合问题，这时候如果依然把这些不合理的可能性也深度遍历到底的话，耗费的资源和时间是超量的。
所以我们需要进行剪枝

以下开始对回溯法中常见的剪枝思路进行分析：
其实由于回溯法是有一定顺序的去遍历的，所以我们可以从此处入手，排除重复可能性
以下以leetcode38题的组合总和为例进行分析：
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有# 可以使数字和为 target 的组合。
# candidates 中的数字可以无限制重复被选取。
# 说明：
# 所有数字（包括 target）都是正整数。
# 解集不能包含重复的组合。 
# 示例 1:
# 输入: candidates = [2,3,6,7], target = 7,
# 所求解集为:
# [
#   [7],
#   [2,2,3]
# ]
# 示例 2:
# 输入: candidates = [2,3,5], target = 8,
# 所求解集为:
# [
#   [2,2,2,2],
#   [2,3,3],
#   [3,5]
# ]

这个题目主要提到了一点：在回溯过程中，所给定的元素是否可以重用的问题，由于不接受重复的解，所以这其实是一个组合问题，
所以我们要讨论的是对于一个可以重用元素的情况，如何剪掉不合理的枝，对于一个已经排序的数组而言，剪除重用元素的枝的方案很简单，
比如1+2+1和1+1+2其实是两种相同的答案，理论上按照回溯法的顺序，哪一种可能性是后来重复的呢？明显是121这种，从这点我们很容易看出，
对于一个已排序的可重用元素数组，想要剪除他的枝只需要增加一个观察变量就可以了，我设定一个观察变量，变量于每一个循环的外部进行记录。
用来观察121这种可能有没有存在后面取用的元素比前面取用的元素小的情况，如果出现了，那么这种情况已经在另一种更早出现的情况中出现了，所以剪除该可能。

接下来从leetcode40题分析，另一种剪枝情况：
# 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
# candidates 中的每个数字在每个组合中只能使用一次。
# 说明：
# 所有数字（包括目标数）都是正整数。
# 解集不能包含重复的组合。 
# 示例 1:
# 输入: candidates = [10,1,2,7,6,1,5], target = 8,
# 所求解集为:
# [
#   [1, 7],
#   [1, 2, 5],
#   [2, 6],
#   [1, 1, 6]
# ]
# 示例 2:
# 输入: candidates = [2,5,2,1,2], target = 5,
# 所求解集为:
# [
#   [1,2,2],
#   [5]
# ]

在这个题目中我们面临另一种要求：提供有重复元素的数组，但是不能重用元素（这是当然的，能重用元素那要重复的元素根本没用）
以下开始分析，如果元素是禁止重用的话，他的组合的可能性中，应该排除掉的枝是什么样的枝
举例：125，152，215，251，512，521这几种可能性中只有最上面一种是合理的可能性，其他都是重复可能需要剪除，那么剪除的方案是？
在这种情况下，枝只有一种
很简单，我们首先对题目给予的数组进行排序，然后逐渐压缩下一轮可选用的数据元素就可以了，从[12345678]中选元素，我们在取得一个元素后
把这个元素排除掉，后面的枝将会被剪除(这其实是最常见的基础回溯写法)
但是上面的情况中明显是没有重复元素的，那么我们试试加入重复元素这个条件[1,1,5]，这个情况下所有可能包括：
115，151，115，151，511，511注意这里仍然只有一个答案，但是却出现了两类枝，一类是基础的，在使用一个元素后把该元素屏蔽掉，那么就可以去除
但是还有第二类，他们是不同的元素，但是他们的值是一样的比如115和115，他分别是第一种和第三种可能，明显他们采用的是不同的元素1，但是他们的值都为1
所以要被去除，那么应该怎么去除？很简单，只要我们在基础回溯写法中加入一个for循环内部判断变量即可，
在第一位取第一个元素1，第二位取第二个元素1，第三位取5时，这个可能性时正确的。
但是在第一位取第二个元素1，第二位取第一个元素1时，我们要否决这种可能，否决的方法是：第一位取元素时，取了第一个元素1，在经过很多中可能性之后，
将会到达第一位取第二个元素1的情况，但是这种情况我们明显已经尝试过了要被否决掉，那么我们可以得出一个判断依据，如果在同一个for循环中，
你选的这个数不大于之前选用的数，你的可能性就被否决



综上所述：
面对排列问题：先排序(可以不排序)，然后使用visit表，跟组合问题最大的区别在于125和512是否共存，如果使用visit表，默认是共存的，正符合排列的思想
面对组合问题：首先先排序(其实不排序也可以，但是会麻烦很多)由于是组合，所以125和512是不能共存的，方法有两种：
1)使用visit表，并且增加一个判断, 使第一个元素不可能取用到5，比如for i in range(len(visit) - 2):但是这段循环要写在主函数中，
（因为只有取用第一个数时需要判断，后面取用的都不需要判断，所以这部分不能写到递归函数里面去）
这样的情况下visit表中最后那些太大的元素是当不了第一位元素的(里面的2是需要取用的元素量-1，比如我要从4个元素中取3个元素，
那么第二个元素是否可以成为首位元素？可以，但是第3，4位就不可以了，因为被剪枝了，就-2)
2)不使用visit表，直接for i in range(index， len(nums)),当第一位元素选用5的时候会发现后面没有足够的数字可选完成一个3元素组合，
当然这种情况答案上剪枝了，但是中间的时间没有省下来，因为他还是尝试了，只是发现元素不够所以没记入答案而已。
（注意78题子集恰好用这种，因为他需要最多3个元素，但是只有一个元素时也要记入列表中，这种情况刚好是这个方法的特点）
上面是基于普通回溯要求(数组中一个数值只会出现一次)

如果出现：元素可以复用，或者存在相同的值, 那么就要从上面的做法中选一(建议选用后一种)，并且在for循环内部增加一个判断变量，
用来记录这个循环中上一次的值和这一次的值的对比，如果是一样大的，那说明这种可能性已经出现过了，跳过(不可能前大于后的因为是有序数组)。
比如1135四个元素中选3元素组合1(第一个1)1(第二个1)3和1(第二个1)1(第一个1)3是重复的，后者要被剪枝


最后，另一大类，关于回溯算法，很多时候不是关于数组的值的问题，比如讨论两点之间是否连通这种情况，必须使用visit表甚至有可能题目
本身给我们的就是一个类似visit的表
