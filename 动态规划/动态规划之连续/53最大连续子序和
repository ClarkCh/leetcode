# 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
# 示例:
# 输入: [-2,1,-3,4,-1,2,1,-5,4],
# 输出: 6
# 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
# def maxSubArray(self, nums: List[int]) -> int:


# 思路：这道是一道典型的动态规划的题目, 原因是这道题目有最优子结构, 只要求出各个部分的最优情况
# 结果必然出现在其中, 但是不一定是出现在表中的最后一项, 这里恰好是这种情况
# 针对以下这个例子进行讲解
# [8, -4, 2] 从左往右看, 使用储存表dp, 注意这里dp的含义是重点：
# dp[n]的含义是站在索引为n的这个点上看, 所能选择的最大连续子序和
# 对于第一个数来说必然只能选自己, 对于第二个数来说, 理论上存在三种可能
# 1)选前一个最大的连续子序和但是不选自己(因为觉得自己是个负影响, 即负数)
# 2)选自己(前面的dp[n-1]是负数)
# 3)选自己与dp[n-1]的和(前面和自己都是正数)
# 注意前面三种情况其实有一种是不可选的, 那就是第一种, 从案例看吧
# 如果对于-4所在的索引1来说, 他选第一种, 所以dp[1] = 8, 这样会使索引2认为, 我可以和8组合
# 这样构成的数十分大, 其实这是错误的, 因为8跟索引2是有间隔的, 所以其实索引2是不可能能够选择和8组合的
# 可见第一种可能性是存在的, 但是却不是能填入dp[1]的存在, 值得庆幸的是, 他会被储存在dp[1]的前一格
# 也就是说这个dp表其实是有完整记录下三种可能性的, 但是第一种可能性并不是存在对应的索引处, 而是储存在
# 这个表的某一个地方中, 但不管怎么说, 第一种可能是一个已经被固定的值, 他有竞争最优结果的可能, 但是不可
# 被联合, 而第二三种都是可以被联合的, 为什么dp表的对应索引只能储存可以被联合的内容?
# 这是因为动态规划实则是一种依靠前后关系来迭代创建最优结果的算法思想, 所以不可被联合的数据, 其实不算是
# 动态规划中前后关系的依据, 所以我将使用动态规划的思想, 并依据第二第三种可能进行迭代更新最优结果
# 并且在更新完成最优的dp表后遍历一次dp表找出最大值, 因为我前面提到过第一种可能不能作为前后关系的依据, 却
# 也是正确答案的有力竞争者, 所以最后必须遍历一次找出最大值才能找到所有可能


class Solution:
    def maxSubArray(self, nums):
        if len(nums) == 1:
            return nums[0]
        dp = [nums[0]] * len(nums)
        for i in range(1, len(nums)):
            dp[i] = max(nums[i], nums[i]+dp[i-1])
        return max(dp)
